/*
 * TelstraSMSAUSLib
 *
 * This file was automatically generated by APIMATIC BETA v2.0 on 05/16/2016
 */
package com.telstra.api.controllers;

import android.util.Log;

import com.android.volley.VolleyError;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.telstra.api.APIException;
import com.telstra.api.APIHelper;
import com.telstra.api.Configuration;
import com.telstra.api.http.client.APICallBack;
import com.telstra.api.http.client.HttpClient;
import com.telstra.api.http.client.HttpContext;
import com.telstra.api.http.request.HttpRequest;
import com.telstra.api.http.response.HttpResponse;
import com.telstra.api.http.response.HttpStringResponse;
import com.telstra.api.models.AuthenticationResponse;
import com.telstra.api.models.GetAuthenticationInput;
import com.telstra.api.models.MessageStatus;
import com.telstra.api.models.ResponseStatusEnum;
import com.telstra.api.models.SendMessageRequest;
import com.telstra.api.models.SendMessageResponse;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;
import java.util.Calendar;
import java.util.Date;
import java.text.SimpleDateFormat;

import org.json.JSONObject;
import java.io.InputStream;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;


public class APIController extends BaseController {
    /**
     * Initialize the base controller using the given http client
     */
    public APIController() {
        super();
    }

    /**
     * Initialize the base controller using the given http client
     *
     * @param _client The given http client */
    public APIController(HttpClient _client) {
        super(_client);
    }

    /**
     * get access token using customerKey and customerSecret
     * @return Returns the AuthenticationResponse response from the API call
     */
    public String getAccessToken() {
        Date now = new Date();
        if (now.before(Configuration.tokenExpiry)) {
            return Configuration.oAuthAccessToken;
        }

        GetAuthenticationInput authRequest = new GetAuthenticationInput();
        authRequest.setClientId(Configuration.consumerKey);
        authRequest.setClientSecret(Configuration.consumerSecret);

        this.getAuthenticationAsync(authRequest, new APICallBack<AuthenticationResponse>() {
            public void onSuccess(HttpContext context, AuthenticationResponse response) {
                Configuration.oAuthAccessToken = response.getAccessToken();

                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.SECOND, Integer.parseInt(response.getExpiresIn()));
                Configuration.tokenExpiry = cal.getTime();
            }

            public void onFailure(HttpContext context, Throwable error) {
                Configuration.oAuthAccessToken = "";
                Configuration.tokenExpiry = new Date(0);
                Log.i("getAccessToken", "Get token failed, reset Configuration.oAuthAccessToken");
            }
        });

        return Configuration.oAuthAccessToken;
    }

    public String getAccessTokenSync(){
        Date now = new Date();
        if (now.before(Configuration.tokenExpiry)) {
            Log.i("getAccessToken", "Cached token = "+Configuration.oAuthAccessToken);
            return Configuration.oAuthAccessToken;
        }

        String baseUri = Configuration.baseUri;
        StringBuilder queryBuilder = new StringBuilder(baseUri);
        queryBuilder.append("/oauth/token");

        APIHelper.appendUrlWithQueryParameters(queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5503757831781780302L;
            {
                put( "client_id", Configuration.consumerKey);
                put( "client_secret", Configuration.consumerSecret);
                put( "grant_type", "client_credentials" );
                put( "scope", "SMS" );
            }});
        final String url = APIHelper.cleanUrl(queryBuilder);

        Thread thread = new Thread(new Runnable()
        {
            @Override
            public void run()
            {
                try
                {
                    InputStream inputStream = null;
                    String result = "";
                    try {
                        // create HttpClient
                        org.apache.http.client.HttpClient httpclient = new DefaultHttpClient();

                        // make GET request to the given URL
                        org.apache.http.HttpResponse httpResponse = httpclient.execute(new HttpGet(url));

                        // receive response as inputStream
                        inputStream = httpResponse.getEntity().getContent();

                        // convert inputstream to string
                        if (inputStream != null) {
                            result = convertInputStreamToString(inputStream);
                            JSONObject response = new JSONObject(result);
                            Configuration.oAuthAccessToken = response.getString("access_token");

                            String expiry_sec = response.getString("expires_in");
                            Calendar cal = Calendar.getInstance();
                            cal.add(Calendar.SECOND, Integer.parseInt(expiry_sec));
                            Configuration.tokenExpiry = cal.getTime();
                        }
                        else
                            result = "Did not work!";

                    } catch (Exception e) {
                        Log.d("InputStream", e.getLocalizedMessage());
                    }
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        });

        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Log.i("getAccessToken", "Get token = "+Configuration.oAuthAccessToken);
        return Configuration.oAuthAccessToken;
    }

    /*
     * send SMS to myself
     */
    public void sendSelfSMSAsync(
            final String body,
            final APICallBack<SendMessageResponse> callBack
    ) throws JsonProcessingException {
        SendMessageRequest messageRequest = new SendMessageRequest();
        messageRequest.setTo(Configuration.selfMobileNumber);
        messageRequest.setBody(body);

        this.createSMSMessageAsync(messageRequest, callBack);
    }

    /**
     * Send an SMS to an AUS mobile, returns A unique identifier for the SMS response  (messageId)
     * @param    messageRequest    Required parameter: TODO: type description here
	 * @return	Returns the SendMessageResponse response from the API call*/
    public void createSMSMessageAsync(
            final SendMessageRequest messageRequest,
            final APICallBack<SendMessageResponse> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri);
        queryBuilder.append("/sms/messages");
        //validate and preprocess url
        String queryUrl = APIHelper.cleanUrl(queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4626620208241550586L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
//                    put( "content-type", "application/json; charset=utf-8" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken));
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.postBody(queryUrl, headers, APIHelper.serialize(messageRequest));

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            SendMessageResponse result = APIHelper.deserialize(((HttpStringResponse)response).getBody(),
                                                        new TypeReference<SendMessageResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(context, result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }
        
    /**
     * Get an Oauth Token
     * @param    GetAuthenticationInput    Object with all parameters
	 * @return	Returns the AuthenticationResponse response from the API call*/
    public void getAuthenticationAsync(
                final GetAuthenticationInput input,
            final APICallBack<AuthenticationResponse> callBack
    ) {
        //the base uri for api requests
        String baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri);
        queryBuilder.append("/oauth/token");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5503757831781780302L;
            {
                    put( "client_id", input.getClientId() );
                    put( "client_secret", input.getClientSecret() );
                    put( "grant_type", "client_credentials" );
                    put( "scope", "SMS" );
            }});
        //validate and preprocess url
        String queryUrl = APIHelper.cleanUrl(queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5218405291673361176L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        Log.i("getAccessToken", "getAuthenticationAsync queryUrl = " + queryUrl);
        //https://api.telstra.com/v1/oauth/token?grant_type=client_credentials&scope=SMS&client_secret=AUbyh8CJy8gASog1&client_id=ZDuzM5gKWl9IM8G4e0VMH2bKorRIU33t
        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.get(queryUrl, headers, null);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            AuthenticationResponse result = APIHelper.deserialize(((HttpStringResponse)response).getBody(),
                                                        new TypeReference<AuthenticationResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(context, result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }
        
    /**
     * Use the unique identifier (messageId) returned as returned in the response from the Send SMS method to get the status
     * @param    messageID    Required parameter: The unique id representing the message request
	 * @return	Returns the MessageStatus response from the API call*/
    public void getMessageStatusAsync(
            final String messageID,
            final APICallBack<MessageStatus> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri);
        queryBuilder.append("/sms/messages/{messageID}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5415931548764929456L;
            {
                    put( "messageID", messageID );
            }});
        //validate and preprocess url
        String queryUrl = APIHelper.cleanUrl(queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5244083501253982102L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.get(queryUrl, headers, null);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            MessageStatus result = APIHelper.deserialize(((HttpStringResponse)response).getBody(),
                                                        new TypeReference<MessageStatus>(){});

                            //let the caller know of the success
                            callBack.onSuccess(context, result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }
        
    /**
     * The recipients of your SMS messages can send a reply which you can retrieve using the Get Message Response method. Pass through the unique identifier (messageId) returned as returned in the response from the Send SMS method and you will receive the reply and the timestamp.
     * @param    messageID    Required parameter: the unique id of the message request
	 * @return	Returns the ResponseStatusEnum response from the API call*/
    public void getMessageResponseAsync(
            final String messageID,
            final APICallBack<ResponseStatusEnum> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri);
        queryBuilder.append("/sms/messages/{messageID}/response");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4630838153845451542L;
            {
                    put( "messageID", messageID );
            }});
        //validate and preprocess url
        String queryUrl = APIHelper.cleanUrl(queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5655003305670962017L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.get(queryUrl, headers, null);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            ResponseStatusEnum result = ResponseStatusEnum.valueOf(((HttpStringResponse)response).getBody());

                            //let the caller know of the success
                            callBack.onSuccess(context, result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }

    // convert inputstream to String
    private static String convertInputStreamToString(InputStream inputStream) throws IOException{
        BufferedReader bufferedReader = new BufferedReader( new InputStreamReader(inputStream));
        String line = "";
        String result = "";
        while((line = bufferedReader.readLine()) != null)
            result += line;

        inputStream.close();
        return result;

    }
        
}